# HTTP Authentication Server with Cookie-Based Sessions

A complete HTTP server implementation featuring dual authentication mechanisms: username/password authentication and session-based cookie management. Built from scratch using Python socket programming to demonstrate HTTP protocol understanding and secure web application development.

## Table of Contents
- [Overview](#overview)
- [Key Achievements](#key-achievements)
- [Technologies Used](#technologies-used)
- [System Architecture](#system-architecture)
- [Authentication Mechanisms](#authentication-mechanisms)
- [Project Structure](#project-structure)
- [Technical Implementation](#technical-implementation)
- [Usage](#usage)
- [Testing](#testing)
- [Requirements](#requirements)

## Overview

This project implements a custom HTTP server that handles user authentication through two complementary mechanisms: traditional username/password POST requests and stateful cookie-based sessions. The server demonstrates complete HTTP protocol implementation including request parsing, response generation, and secure session management.

The system provides:
- **Multi-User Authentication** - Supports multiple users with individual credentials and secrets
- **Dual Authentication Paths** - Username/password login and cookie-based session validation
- **Secure Session Management** - Random 64-bit token generation and session tracking
- **Complete HTTP Protocol** - Custom implementation with proper headers and response codes
- **Logout Functionality** - Cookie expiration and session cleanup

## Key Achievements

- **Built HTTP server from scratch** using raw TCP socket programming
- **Implemented dual authentication system** with username/password and cookie validation
- **Developed secure session management** using cryptographically random 64-bit tokens
- **Created complete HTTP protocol handler** supporting GET/POST requests with proper headers
- **Achieved 100% test case coverage** across all authentication scenarios
- **Implemented stateful sessions** over stateless HTTP protocol using cookies
- **Built comprehensive logout system** with cookie expiration and cleanup

## Technologies Used

- **Language**: Python 3
- **Networking**: TCP Socket Programming, Multi-threaded Server Architecture
- **Protocols**: HTTP/1.1 Implementation, Cookie Management
- **Security**: Session Token Generation, Secure Authentication
- **Skills**: Network programming, Web protocols, Session management, Security implementation

## System Architecture

```
                    HTTP Client (Browser/curl)
                             |
                    (HTTP GET/POST Requests)
                             |
                      HTTP Server (server.py)
                        /         \
               Authentication      Session
                 System           Management
                    |                 |
            Username/Password    Cookie Validation
             Authentication       & Generation
                    |                 |
              User Database      Session Store
            (passwords.txt)      (in-memory)
                    |
               Secret Data
              (secrets.txt)
```

## Authentication Mechanisms

### 1. Username/Password Authentication
- **Input Method**: HTTP POST request with form data
- **Validation**: Credentials checked against `passwords.txt` database
- **Success Flow**: User authenticated → Secret data displayed → Session cookie generated
- **Failure Flow**: Invalid credentials → Error page displayed → Re-authentication required

### 2. Cookie-Based Session Authentication
- **Cookie Generation**: 64-bit random token using `random.getrandbits(64)`
- **Session Storage**: Token-to-username mapping in server memory
- **Automatic Recognition**: Valid cookies bypass login requirements
- **Security**: HttpOnly cookies prevent client-side access

### 3. Logout Functionality
- **Cookie Expiration**: Sets cookie expiry to past date (Jan 1, 1970)
- **Session Cleanup**: Removes token from server session store
- **Immediate Effect**: Forces re-authentication for subsequent requests

## Project Structure

```
├── server.py                 # Main HTTP server implementation
├── test.py                   # Enhanced server with improved error handling
├── passwords.txt             # User credentials database
├── secrets.txt               # User secret data database
├── cookies.txt               # Cookie storage (generated by curl)
├── report.pdf               # Technical implementation report
└── README.md                # Project documentation
```

## Technical Implementation

### HTTP Request Parsing
```python
# Parse HTTP headers and body
header_body = req.decode().split('\r\n\r\n')
headers = header_body[0]
body = '' if len(header_body) == 1 else header_body[1]

# Extract cookies from headers
for line in headers.split('\r\n'):
    if line.startswith('Cookie:'):
        cookie_parts = line.split('token=')
        if len(cookie_parts) > 1:
            cookie = cookie_parts[1].split(';')[0].strip()
```

### Session Management
```python
# Generate secure session token
rand_val = random.getrandbits(64)
cookie_str = str(rand_val)
sessions[cookie_str] = username

# Set cookie in HTTP response
headers_to_send = 'Set-Cookie: token=' + cookie_str + '\r\n'
```

### Authentication Flow Logic

#### Case A: Successful Username/Password Login
```python
if name in username_to_password and pwd == username_to_password[name]:
    secret = username_to_secret[name]
    rand_val = random.getrandbits(64)
    sessions[str(rand_val)] = name
    headers_to_send = f'Set-Cookie: token={rand_val}\r\n'
    html_content_to_send = success_page + secret
```

#### Case B: Failed Authentication
```python
else:
    html_content_to_send = bad_creds_page
```

#### Case C: Valid Cookie Authentication
```python
if cookie and cookie in sessions:
    username = sessions[cookie]
    secret = username_to_secret[username]
    html_content_to_send = success_page + secret
```

#### Case D: Invalid Cookie
```python
elif cookie and cookie not in sessions:
    html_content_to_send = bad_creds_page
```

#### Case E: Logout
```python
if body == "action=logout":
    headers_to_send = 'Set-Cookie: token=; expires=Thu, 01 Jan 1970 00:00:00 GMT\r\n'
    html_content_to_send = logout_page
```

### Database Structure

**User Credentials (passwords.txt):**
```
bezos amazon
naiveuser password123
srinivas nicetry
```

**Secret Data (secrets.txt):**
```
bezos kaching
naiveuser mymostsecretpassword
srinivas nothingtoseehere
```

## Usage

### Starting the Server
```bash
# Default port (8080)
python3 server.py

# Custom port
python3 server.py 45006
```

### Browser Access
```
http://localhost:8080
```

### Command Line Testing with curl

#### Basic Login
```bash
curl -d "username=bezos&password=amazon" http://localhost:8080/
```

#### Cookie-based Authentication
```bash
# Login and save cookie
curl -d "username=bezos&password=amazon" -c cookies.txt http://localhost:8080/

# Use saved cookie
curl -b cookies.txt http://localhost:8080/
```

#### Logout
```bash
curl -d "action=logout" -b cookies.txt -c cookies.txt http://localhost:8080/
```

## Testing

### Comprehensive Test Scenarios

The system handles all specified test cases:

1. **Basic Access**: No credentials, no cookies → Login page
2. **Successful Login**: Valid credentials → Success page with secret
3. **Invalid Username**: Non-existent user → Error page
4. **Invalid Password**: Wrong password for valid user → Error page  
5. **Missing Fields**: Username or password missing → Error page
6. **Valid Cookie**: Authenticated cookie → Success page
7. **Cookie Priority**: Valid cookie overrides invalid credentials → Success page
8. **Credential Priority**: Valid credentials work with valid cookie → Success page
9. **Invalid Cookie**: Bad cookie with valid credentials → Error page
10. **Logout with Valid Cookie**: Successful logout → Logout page
11. **Logout with Invalid Cookie**: Logout attempt → Logout page

### Testing Commands

```bash
# Test successful authentication
curl -d "username=bezos&password=amazon" http://localhost:8080/

# Test invalid credentials  
curl -d "username=bezos&password=wrong" http://localhost:8080/

# Test cookie functionality
curl -d "username=bezos&password=amazon" -c cookies.txt http://localhost:8080/
curl -b cookies.txt http://localhost:8080/

# Test logout
curl -d "action=logout" -b cookies.txt http://localhost:8080/
```

## Requirements

### System Requirements
- **Python 3.x**
- **Linux/Unix Environment** (tested on iLab machines)
- **Network Access** for HTTP connections
- **TCP Port Access** (default: 8080)

### Python Libraries
- `socket` - TCP socket communication
- `random` - Secure token generation
- `sys` - Command line arguments
- `urllib.parse` - URL/form data parsing (enhanced version)
- Built-in libraries only (no external dependencies)

### Installation
```bash
# Clone repository
git clone <repository-url>
cd HTTP-Authentication-Protocol-Server

# Ensure database files are present
ls passwords.txt secrets.txt

# Run server
python3 server.py [port]
```

## Performance & Security

### Security Features
- **Cryptographically Secure Tokens**: 64-bit random token generation
- **Session Isolation**: Each user session tracked independently
- **Automatic Cookie Expiration**: Logout properly clears client cookies
- **Domain-Bound Cookies**: Cookies restricted to server domain
- **Input Validation**: Proper handling of malformed requests

### Architecture Benefits
- **Stateful Sessions**: Maintains user state over stateless HTTP
- **Scalable Design**: In-memory session store for fast lookups
- **Protocol Compliance**: Full HTTP/1.1 implementation
- **Error Handling**: Graceful handling of edge cases and invalid inputs

---

**Key Learning Outcomes**: This project demonstrates deep understanding of HTTP protocol internals, session management, web security principles, and low-level network programming. The implementation showcases ability to build secure web applications from fundamental networking concepts.
